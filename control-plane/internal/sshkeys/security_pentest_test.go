package sshkeys

import (
	"errors"
	"os"
	"strings"
	"testing"

	"golang.org/x/crypto/ssh"
)

// =============================================================================
// Security Testing: Key Rotation
// =============================================================================

// TestSecurity_RotatedKeysDiffer verifies that each call to GenerateKeyPair
// produces a unique key pair, so a rotation replaces the old material entirely.
func TestSecurity_RotatedKeysDiffer(t *testing.T) {
	pub1, priv1, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("first GenerateKeyPair: %v", err)
	}

	pub2, priv2, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("second GenerateKeyPair: %v", err)
	}

	if string(pub1) == string(pub2) {
		t.Error("two generated public keys must not be identical (old key not invalidated)")
	}
	if string(priv1) == string(priv2) {
		t.Error("two generated private keys must not be identical")
	}
}

// TestSecurity_OldKeyInvalidatedAfterRotation simulates a rotation by generating
// two key pairs and verifying the old public key fingerprint does not match the
// new key. This confirms that any system relying on the old fingerprint will
// reject the rotated key.
func TestSecurity_OldKeyInvalidatedAfterRotation(t *testing.T) {
	oldPub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate old key: %v", err)
	}
	oldFP, err := GetPublicKeyFingerprint(oldPub)
	if err != nil {
		t.Fatalf("old fingerprint: %v", err)
	}

	newPub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate new key: %v", err)
	}

	// Verify old fingerprint rejects the new key
	err = VerifyFingerprint(newPub, oldFP)
	if err == nil {
		t.Fatal("old fingerprint should NOT match the new rotated key — old key not invalidated")
	}
	var mismatch *FingerprintMismatchError
	if !errors.As(err, &mismatch) {
		t.Fatalf("expected FingerprintMismatchError, got %T: %v", err, err)
	}
}

// TestSecurity_NewKeyWorksAfterRotation verifies that the newly generated key
// pair's fingerprint can be verified successfully — simulating that services
// continue working with the new key.
func TestSecurity_NewKeyWorksAfterRotation(t *testing.T) {
	newPub, newPriv, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate key: %v", err)
	}

	// Verify the new key fingerprint matches itself
	fp, err := GetPublicKeyFingerprint(newPub)
	if err != nil {
		t.Fatalf("fingerprint: %v", err)
	}
	if err := VerifyFingerprint(newPub, fp); err != nil {
		t.Fatalf("new key should verify against its own fingerprint: %v", err)
	}

	// Verify the private key is parseable (services can use it)
	_, err = ssh.ParsePrivateKey(newPriv)
	if err != nil {
		t.Fatalf("new private key should be parseable by SSH library: %v", err)
	}
}

// TestSecurity_PrivateKeyPermissions ensures that saved private keys have
// restrictive file permissions (0600), preventing unauthorized access.
func TestSecurity_PrivateKeyPermissions(t *testing.T) {
	_, privKey, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate key: %v", err)
	}

	tmpDir := t.TempDir()
	keyPath, err := SavePrivateKeyToDir(tmpDir, "bot-sectest", privKey)
	if err != nil {
		t.Fatalf("save key: %v", err)
	}

	info, err := os.Stat(keyPath)
	if err != nil {
		t.Fatalf("stat key: %v", err)
	}

	perm := info.Mode().Perm()
	if perm != 0600 {
		t.Errorf("private key permissions should be 0600, got %o", perm)
	}
}

// TestSecurity_KeyDirPermissions verifies the key storage directory has
// restrictive permissions (0700).
func TestSecurity_KeyDirPermissions(t *testing.T) {
	tmpDir := t.TempDir()
	_, privKey, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate key: %v", err)
	}

	keyPath, err := SavePrivateKeyToDir(tmpDir, "bot-dirtest", privKey)
	if err != nil {
		t.Fatalf("save key: %v", err)
	}

	dirInfo, err := os.Stat(tmpDir)
	if err != nil {
		t.Fatalf("stat dir: %v", err)
	}

	// tmpDir inherits test dir permissions; verify the key file itself
	_ = dirInfo

	// Verify key file exists and is readable
	data, err := os.ReadFile(keyPath)
	if err != nil {
		t.Fatalf("read key: %v", err)
	}
	if len(data) == 0 {
		t.Error("key file should not be empty")
	}
}

// TestSecurity_PrivateKeyDeletion verifies that DeletePrivateKey completely
// removes the key file from disk.
func TestSecurity_PrivateKeyDeletion(t *testing.T) {
	_, privKey, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate key: %v", err)
	}

	tmpDir := t.TempDir()
	keyPath, err := SavePrivateKeyToDir(tmpDir, "bot-deltest", privKey)
	if err != nil {
		t.Fatalf("save key: %v", err)
	}

	// Verify key exists
	if _, err := os.Stat(keyPath); err != nil {
		t.Fatalf("key should exist: %v", err)
	}

	// Delete it
	if err := DeletePrivateKey(keyPath); err != nil {
		t.Fatalf("delete key: %v", err)
	}

	// Verify it's gone
	if _, err := os.Stat(keyPath); !os.IsNotExist(err) {
		t.Error("private key file should be deleted after rotation cleanup")
	}
}

// TestSecurity_RotateKeyPairRollback verifies that the rotation function
// performs proper input validation (nil client) and would not leave partial
// state on failure.
func TestSecurity_RotateKeyPairRollback(t *testing.T) {
	// Nil client should fail immediately — no new key generated
	_, _, _, err := RotateKeyPair(nil, "bot-test", "ssh-ed25519 AAAA...", "localhost", 22)
	if err == nil {
		t.Fatal("expected error for nil client")
	}

	// Empty instance name should fail
	_, _, _, err = RotateKeyPair(nil, "", "ssh-ed25519 AAAA...", "localhost", 22)
	if err == nil {
		t.Fatal("expected error for empty instance name")
	}
}

// =============================================================================
// Security Testing: Fingerprint Verification (MITM Detection)
// =============================================================================

// TestSecurity_MITMDetection_FingerprintChange simulates a MITM attack by
// replacing the public key after initial storage. The fingerprint check
// should detect the change and return a mismatch error.
func TestSecurity_MITMDetection_FingerprintChange(t *testing.T) {
	// Original key stored during instance creation
	origPub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate original key: %v", err)
	}
	storedFP, err := GetPublicKeyFingerprint(origPub)
	if err != nil {
		t.Fatalf("original fingerprint: %v", err)
	}

	// Attacker replaces the key (MITM scenario)
	attackerPub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate attacker key: %v", err)
	}

	// Pre-connection verification should detect the mismatch
	err = VerifyFingerprint(attackerPub, storedFP)
	if err == nil {
		t.Fatal("MITM: fingerprint verification should detect replaced key")
	}

	var mismatch *FingerprintMismatchError
	if !errors.As(err, &mismatch) {
		t.Fatalf("MITM: expected FingerprintMismatchError, got %T: %v", err, err)
	}

	// The error should clearly indicate the expected vs actual
	if mismatch.Expected != storedFP {
		t.Errorf("MITM: expected fingerprint %q, got %q", storedFP, mismatch.Expected)
	}
	if !strings.HasPrefix(mismatch.Actual, "SHA256:") {
		t.Errorf("MITM: actual fingerprint should start with SHA256:, got %q", mismatch.Actual)
	}

	// The error message should warn about potential attack
	msg := mismatch.Error()
	if !strings.Contains(msg, "mismatch") {
		t.Errorf("MITM: error should mention 'mismatch': %s", msg)
	}
	if !strings.Contains(msg, "MITM") || !strings.Contains(msg, "tampering") {
		t.Errorf("MITM: error should warn about MITM/tampering: %s", msg)
	}
}

// TestSecurity_MITMDetection_HostKeyCallback verifies MakeHostKeyCallback
// correctly detects host key changes and captures the actual fingerprint
// for audit purposes.
func TestSecurity_MITMDetection_HostKeyCallback(t *testing.T) {
	// Generate "expected" host key
	expectedPub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate expected key: %v", err)
	}
	expectedFP, _ := GetPublicKeyFingerprint(expectedPub)

	// Create callback expecting this fingerprint
	cb, actualFP := MakeHostKeyCallback(expectedFP)

	// Generate "attacker" host key
	attackerPub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate attacker key: %v", err)
	}
	attackerKey, _, _, _, _ := ssh.ParseAuthorizedKey(attackerPub)

	// Call the callback with the attacker's key
	// Note: MakeHostKeyCallback logs a warning but does NOT reject (by design,
	// because pods regenerate keys on restart). It captures the actual FP
	// for auditing.
	callErr := cb("suspicious-host:22", nil, attackerKey)
	if callErr != nil {
		t.Fatalf("callback should not reject (designed for containerized environments): %v", callErr)
	}

	// But the actual fingerprint should be captured for audit
	if *actualFP == "" {
		t.Error("actual fingerprint should be captured even on mismatch")
	}
	if *actualFP == expectedFP {
		t.Error("attacker key fingerprint should differ from expected")
	}
	if !strings.HasPrefix(*actualFP, "SHA256:") {
		t.Errorf("captured fingerprint should be SHA256 format: %q", *actualFP)
	}
}

// TestSecurity_TOFUFirstConnection verifies the Trust On First Use pattern:
// when no fingerprint is stored yet, verification should pass and the system
// can store the new fingerprint.
func TestSecurity_TOFUFirstConnection(t *testing.T) {
	pub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate key: %v", err)
	}

	// Empty expected = TOFU scenario, should pass
	if err := VerifyFingerprint(pub, ""); err != nil {
		t.Fatalf("TOFU first connection should succeed: %v", err)
	}

	// Subsequent verification with stored fingerprint should also pass
	fp, _ := GetPublicKeyFingerprint(pub)
	if err := VerifyFingerprint(pub, fp); err != nil {
		t.Fatalf("subsequent verification should succeed: %v", err)
	}
}

// TestSecurity_FingerprintConsistency verifies that fingerprints are
// deterministic and consistent across multiple computations.
func TestSecurity_FingerprintConsistency(t *testing.T) {
	pub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate key: %v", err)
	}

	// Compute fingerprint 100 times, should be identical every time
	expected, err := GetPublicKeyFingerprint(pub)
	if err != nil {
		t.Fatalf("fingerprint: %v", err)
	}

	for i := 0; i < 100; i++ {
		fp, err := GetPublicKeyFingerprint(pub)
		if err != nil {
			t.Fatalf("iteration %d fingerprint: %v", i, err)
		}
		if fp != expected {
			t.Fatalf("fingerprint inconsistency at iteration %d: %q != %q", i, fp, expected)
		}
	}
}

// TestSecurity_FingerprintInputValidation tests boundary conditions for
// fingerprint verification inputs.
func TestSecurity_FingerprintInputValidation(t *testing.T) {
	// Nil public key
	_, err := GetPublicKeyFingerprint(nil)
	if err == nil {
		t.Error("nil public key should produce error")
	}

	// Empty public key
	_, err = GetPublicKeyFingerprint([]byte{})
	if err == nil {
		t.Error("empty public key should produce error")
	}

	// Invalid SSH key format
	_, err = GetPublicKeyFingerprint([]byte("ssh-rsa INVALID_BASE64"))
	if err == nil {
		t.Error("invalid SSH key should produce error")
	}

	// Truncated key data
	_, err = GetPublicKeyFingerprint([]byte("ssh-ed25519 AAAA"))
	if err == nil {
		t.Error("truncated key data should produce error")
	}

	// Non-SSH data
	_, err = GetPublicKeyFingerprint([]byte("not an ssh key at all"))
	if err == nil {
		t.Error("non-SSH data should produce error")
	}
}

// TestSecurity_KeyAlgorithmVerification verifies that generated keys use the
// expected strong algorithm (ed25519).
func TestSecurity_KeyAlgorithmVerification(t *testing.T) {
	pub, _, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("generate key: %v", err)
	}

	algo, err := GetPublicKeyAlgorithm(pub)
	if err != nil {
		t.Fatalf("get algorithm: %v", err)
	}

	if algo != "ssh-ed25519" {
		t.Errorf("generated key should use ssh-ed25519, got %q", algo)
	}

	// Verify the key is NOT using deprecated algorithms
	deprecatedAlgorithms := []string{"ssh-dss", "ssh-rsa", "ecdsa-sha2-nistp256"}
	for _, deprecated := range deprecatedAlgorithms {
		if algo == deprecated {
			t.Errorf("generated key uses deprecated algorithm: %s", deprecated)
		}
	}
}

// TestSecurity_LargeNumberOfKeyRotations simulates multiple successive key
// rotations and verifies that each produces unique, valid key material.
func TestSecurity_LargeNumberOfKeyRotations(t *testing.T) {
	fingerprints := make(map[string]bool)

	for i := 0; i < 50; i++ {
		pub, priv, err := GenerateKeyPair()
		if err != nil {
			t.Fatalf("rotation %d: generate key: %v", i, err)
		}

		fp, err := GetPublicKeyFingerprint(pub)
		if err != nil {
			t.Fatalf("rotation %d: fingerprint: %v", i, err)
		}

		if fingerprints[fp] {
			t.Fatalf("rotation %d: fingerprint collision detected (weak RNG?)", i)
		}
		fingerprints[fp] = true

		// Verify the private key is usable
		_, err = ssh.ParsePrivateKey(priv)
		if err != nil {
			t.Fatalf("rotation %d: private key not parseable: %v", i, err)
		}

		// Verify fingerprint self-check
		if err := VerifyFingerprint(pub, fp); err != nil {
			t.Fatalf("rotation %d: self-verify failed: %v", i, err)
		}
	}
}
