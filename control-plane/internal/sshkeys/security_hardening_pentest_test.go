package sshkeys

import (
	"bufio"
	"os"
	"strings"
	"testing"
)

// =============================================================================
// Security Testing: SSH Server Hardening
// Simulates the checks that tools like ssh-audit would perform by validating
// the sshd configuration file for weak algorithms, insecure defaults, and
// missing hardening directives.
// =============================================================================

// TestSecurity_Hardening_NoWeakCiphers verifies that the sshd configuration
// does not enable weak or deprecated ciphers.
func TestSecurity_Hardening_NoWeakCiphers(t *testing.T) {
	raw, err := os.ReadFile(sshdConfigPath(t))
	if err != nil {
		t.Fatalf("read sshd config: %v", err)
	}
	content := strings.ToLower(string(raw))

	weakCiphers := []string{
		"3des-cbc",
		"blowfish-cbc",
		"cast128-cbc",
		"arcfour",
		"arcfour128",
		"arcfour256",
		"aes128-cbc",
		"aes192-cbc",
		"aes256-cbc",
	}

	for _, cipher := range weakCiphers {
		if strings.Contains(content, cipher) {
			t.Errorf("sshd config should not contain weak cipher: %s", cipher)
		}
	}
}

// TestSecurity_Hardening_NoWeakMACs verifies that the sshd configuration
// does not enable weak MAC algorithms.
func TestSecurity_Hardening_NoWeakMACs(t *testing.T) {
	raw, err := os.ReadFile(sshdConfigPath(t))
	if err != nil {
		t.Fatalf("read sshd config: %v", err)
	}
	content := strings.ToLower(string(raw))

	weakMACs := []string{
		"hmac-md5",
		"hmac-sha1-96",
		"hmac-md5-96",
		"umac-64",
	}

	for _, mac := range weakMACs {
		if strings.Contains(content, mac) {
			t.Errorf("sshd config should not contain weak MAC algorithm: %s", mac)
		}
	}
}

// TestSecurity_Hardening_NoWeakKex verifies that the sshd configuration
// does not enable weak key exchange algorithms.
func TestSecurity_Hardening_NoWeakKex(t *testing.T) {
	raw, err := os.ReadFile(sshdConfigPath(t))
	if err != nil {
		t.Fatalf("read sshd config: %v", err)
	}
	content := strings.ToLower(string(raw))

	weakKex := []string{
		"diffie-hellman-group1-sha1",
		"diffie-hellman-group-exchange-sha1",
		"diffie-hellman-group14-sha1",
	}

	for _, kex := range weakKex {
		if strings.Contains(content, kex) {
			t.Errorf("sshd config should not contain weak key exchange: %s", kex)
		}
	}
}

// TestSecurity_Hardening_NoSSHProtocol1 verifies that SSH protocol 1 is not
// enabled. Protocol 1 has known cryptographic weaknesses.
func TestSecurity_Hardening_NoSSHProtocol1(t *testing.T) {
	raw, err := os.ReadFile(sshdConfigPath(t))
	if err != nil {
		t.Fatalf("read sshd config: %v", err)
	}
	content := strings.ToLower(string(raw))

	if strings.Contains(content, "protocol 1") {
		t.Error("SSH protocol 1 must not be enabled (known cryptographic weaknesses)")
	}
}

// TestSecurity_Hardening_AuthenticationSettings performs a comprehensive check
// of authentication-related security settings.
func TestSecurity_Hardening_AuthenticationSettings(t *testing.T) {
	cfg := parseSSHDConfig(t, sshdConfigPath(t))

	checks := []struct {
		directive string
		expected  string
		desc      string
	}{
		{"passwordauthentication", "no", "password auth should be disabled"},
		{"permitemptypasswords", "no", "empty passwords must be disabled"},
		{"pubkeyauthentication", "yes", "pubkey auth should be enabled"},
		{"permitrootlogin", "prohibit-password", "root login should be key-only"},
		{"kbdinteractiveauthentication", "no", "keyboard-interactive should be disabled"},
		{"hostbasedauthentication", "no", "host-based auth should be disabled"},
		{"usepam", "no", "PAM should be disabled"},
		{"strictmodes", "yes", "strict modes should be enabled"},
	}

	for _, check := range checks {
		v := cfg[check.directive]
		if v != check.expected {
			t.Errorf("security: %s â€” %s should be %q, got %q",
				check.desc, check.directive, check.expected, v)
		}
	}
}

// TestSecurity_Hardening_BruteForceProtection verifies sshd is configured to
// limit brute-force authentication attempts.
func TestSecurity_Hardening_BruteForceProtection(t *testing.T) {
	cfg := parseSSHDConfig(t, sshdConfigPath(t))

	// MaxAuthTries should be low (3 or less)
	if v := cfg["maxauthtries"]; v != "3" {
		t.Errorf("MaxAuthTries should be 3 (limit brute-force), got %q", v)
	}

	// LoginGraceTime should be short
	if v := cfg["logingracetime"]; v != "30" {
		t.Errorf("LoginGraceTime should be 30 (prevent resource exhaustion), got %q", v)
	}

	// MaxStartups should use rate-limiting format
	v := cfg["maxstartups"]
	if v == "" {
		t.Error("MaxStartups should be configured to limit unauthenticated connections")
	} else if !strings.Contains(v, ":") {
		t.Errorf("MaxStartups should use rate-limiting format (e.g. 10:30:60), got %q", v)
	}
}

// TestSecurity_Hardening_ForwardingRestrictions verifies that SSH forwarding
// is properly restricted to prevent lateral movement.
func TestSecurity_Hardening_ForwardingRestrictions(t *testing.T) {
	cfg := parseSSHDConfig(t, sshdConfigPath(t))

	// X11 forwarding must be disabled
	if v := cfg["x11forwarding"]; v != "no" {
		t.Errorf("X11Forwarding must be disabled (prevents X11 attacks), got %q", v)
	}

	// SSH agent forwarding must be disabled
	if v := cfg["allowagentforwarding"]; v != "no" {
		t.Errorf("AllowAgentForwarding must be disabled (prevents key theft), got %q", v)
	}

	// Stream local forwarding must be disabled
	if v := cfg["allowstreamlocalforwarding"]; v != "no" {
		t.Errorf("AllowStreamLocalForwarding must be disabled, got %q", v)
	}

	// TCP forwarding should be local only
	if v := cfg["allowtcpforwarding"]; v != "local" {
		t.Errorf("AllowTcpForwarding should be 'local' (restrict lateral movement), got %q", v)
	}

	// PermitOpen should restrict to known service ports only
	v := cfg["permitopen"]
	if v == "" {
		t.Error("PermitOpen must be configured to restrict port forwarding targets")
	}
	if !strings.Contains(v, "localhost:3000") || !strings.Contains(v, "localhost:8080") {
		t.Errorf("PermitOpen should only allow VNC (3000) and Gateway (8080), got %q", v)
	}
}

// TestSecurity_Hardening_LoggingEnabled verifies that SSH logging is properly
// configured for security monitoring.
func TestSecurity_Hardening_LoggingEnabled(t *testing.T) {
	cfg := parseSSHDConfig(t, sshdConfigPath(t))

	if v := cfg["syslogfacility"]; v != "AUTH" {
		t.Errorf("SyslogFacility should be AUTH for security event categorization, got %q", v)
	}

	if v := cfg["loglevel"]; v != "INFO" {
		t.Errorf("LogLevel should be INFO or higher for security auditing, got %q", v)
	}
}

// TestSecurity_Hardening_NoInsecureDirectives scans the entire config file
// for commonly dangerous directives and patterns.
func TestSecurity_Hardening_NoInsecureDirectives(t *testing.T) {
	raw, err := os.ReadFile(sshdConfigPath(t))
	if err != nil {
		t.Fatalf("read sshd config: %v", err)
	}
	content := strings.ToLower(string(raw))

	dangerousPatterns := []struct {
		pattern string
		reason  string
	}{
		{"protocol 1", "SSH protocol 1 has known vulnerabilities"},
		{"permitrootlogin yes", "unrestricted root login is dangerous"},
		{"permitemptypasswords yes", "empty passwords allow unauthenticated access"},
		{"passwordauthentication yes", "password auth is vulnerable to brute-force"},
		{"challengeresponseauthentication yes", "challenge-response can be exploited"},
		{"kerberosauthentication yes", "Kerberos should be disabled unless required"},
		{"gssapiauthentication yes", "GSSAPI should be disabled unless required"},
		{"permitopen any", "unrestricted port forwarding allows lateral movement"},
		{"gatewayports yes", "gateway ports allow remote hosts to connect to forwarded ports"},
		{"permittunnel yes", "tunneling should be disabled unless required"},
	}

	for _, dp := range dangerousPatterns {
		if strings.Contains(content, dp.pattern) {
			t.Errorf("sshd config contains dangerous directive %q: %s", dp.pattern, dp.reason)
		}
	}
}

// TestSecurity_Hardening_RunScript_LegacyKeyRemoval verifies the sshd run
// script removes legacy host key types (DSA, ECDSA) on startup.
func TestSecurity_Hardening_RunScript_LegacyKeyRemoval(t *testing.T) {
	raw, err := os.ReadFile(sshdRunScriptPath(t))
	if err != nil {
		t.Fatalf("read sshd run script: %v", err)
	}
	content := string(raw)

	// DSA keys must be removed (known weak)
	if !strings.Contains(content, "ssh_host_dsa_key") {
		t.Error("run script should reference DSA host keys for removal")
	}

	// ECDSA keys should be removed (prefer Ed25519)
	if !strings.Contains(content, "ssh_host_ecdsa_key") {
		t.Error("run script should reference ECDSA host keys for removal")
	}

	// rm -f should be used for cleanup
	if !strings.Contains(content, "rm -f") {
		t.Error("run script should use rm -f for legacy key removal")
	}
}

// TestSecurity_Hardening_RunScript_ForegroundMode verifies sshd runs in
// foreground mode for proper process supervision.
func TestSecurity_Hardening_RunScript_ForegroundMode(t *testing.T) {
	raw, err := os.ReadFile(sshdRunScriptPath(t))
	if err != nil {
		t.Fatalf("read sshd run script: %v", err)
	}
	content := string(raw)

	if !strings.Contains(content, "sshd -D") {
		t.Error("sshd must run in foreground mode (-D) for s6 supervision")
	}
}

// TestSecurity_Hardening_RunScript_LogCapture verifies sshd output is
// directed to a log file for the control plane to stream.
func TestSecurity_Hardening_RunScript_LogCapture(t *testing.T) {
	raw, err := os.ReadFile(sshdRunScriptPath(t))
	if err != nil {
		t.Fatalf("read sshd run script: %v", err)
	}
	content := string(raw)

	if !strings.Contains(content, "/var/log/sshd.log") {
		t.Error("sshd should log to /var/log/sshd.log for control plane log streaming")
	}
}

// TestSecurity_Hardening_ConfigFileNoWorldReadable scans the sshd config
// directives line by line to ensure no unexpected or unrecognized directives
// are present that could weaken security.
func TestSecurity_Hardening_ConfigFileWellFormed(t *testing.T) {
	f, err := os.Open(sshdConfigPath(t))
	if err != nil {
		t.Fatalf("open sshd config: %v", err)
	}
	defer f.Close()

	lineNum := 0
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Every non-comment line should have at least a directive and a value
		parts := strings.SplitN(line, " ", 2)
		if len(parts) < 2 {
			t.Errorf("line %d: malformed directive (no value): %q", lineNum, line)
		}
	}

	if err := scanner.Err(); err != nil {
		t.Fatalf("scanning config: %v", err)
	}
}

// TestSecurity_Hardening_FailedAuthLogging verifies the sshd configuration
// supports logging of failed authentication attempts (via LogLevel INFO+).
func TestSecurity_Hardening_FailedAuthLogging(t *testing.T) {
	cfg := parseSSHDConfig(t, sshdConfigPath(t))

	logLevel := cfg["loglevel"]
	acceptableLevels := []string{"INFO", "VERBOSE", "DEBUG", "DEBUG1", "DEBUG2", "DEBUG3"}

	found := false
	for _, level := range acceptableLevels {
		if logLevel == level {
			found = true
			break
		}
	}

	if !found {
		t.Errorf("LogLevel must be INFO or higher to capture failed auth attempts, got %q", logLevel)
	}
}
