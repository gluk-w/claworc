package sshmanager

import (
	"fmt"
	"strings"
	"sync"
	"testing"
	"time"
)

// =============================================================================
// Security Testing: Rate Limiting (Brute-force Protection)
// =============================================================================

// TestSecurity_RapidReconnections verifies that rapid connection attempts
// trigger rate limiting, blocking brute-force attacks.
func TestSecurity_RapidReconnections(t *testing.T) {
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 10,
		MaxConsecFailures:    5,
		BlockDuration:        5 * time.Minute,
	})

	// Simulate 10 rapid connection attempts (the maximum allowed)
	for i := 0; i < 10; i++ {
		if err := rl.Allow("brute-target"); err != nil {
			t.Fatalf("attempt %d should be allowed (within limit): %v", i+1, err)
		}
	}

	// 11th attempt must be blocked
	err := rl.Allow("brute-target")
	if err == nil {
		t.Fatal("rapid reconnection beyond limit should be blocked (brute-force protection failure)")
	}
	if !strings.Contains(err.Error(), "rate limit exceeded") {
		t.Errorf("error should indicate rate limit: %v", err)
	}
}

// TestSecurity_LegitimateReconnectionNotBlocked verifies that a legitimate
// user who reconnects after the window expires is not falsely blocked.
func TestSecurity_LegitimateReconnectionNotBlocked(t *testing.T) {
	now := time.Now()
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 3,
		MaxConsecFailures:    5,
		BlockDuration:        5 * time.Minute,
	})
	rl.nowFn = func() time.Time { return now }

	// Use up 3 attempts
	for i := 0; i < 3; i++ {
		rl.Allow("legit-user")
	}

	// Blocked now
	if err := rl.Allow("legit-user"); err == nil {
		t.Fatal("should be rate limited after exhausting attempts")
	}

	// Wait for window to expire (legitimate user returns later)
	now = now.Add(61 * time.Second)

	// Should be allowed again
	if err := rl.Allow("legit-user"); err != nil {
		t.Fatalf("legitimate user should not be blocked after window expiry: %v", err)
	}
}

// TestSecurity_ConsecutiveFailureBlock verifies that consecutive authentication
// failures trigger a temporary block (defense against credential stuffing).
func TestSecurity_ConsecutiveFailureBlock(t *testing.T) {
	now := time.Now()
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 100,
		MaxConsecFailures:    5,
		BlockDuration:        5 * time.Minute,
	})
	rl.nowFn = func() time.Time { return now }

	// Record 5 consecutive failures
	for i := 0; i < 5; i++ {
		rl.RecordFailure("attack-target")
	}

	// Should be blocked
	err := rl.Allow("attack-target")
	if err == nil {
		t.Fatal("instance should be blocked after 5 consecutive failures")
	}
	if !strings.Contains(err.Error(), "connection blocked") {
		t.Errorf("error should indicate blocking: %v", err)
	}

	// Verify the block duration is enforced
	status := rl.GetStatus("attack-target")
	if !status.Blocked {
		t.Error("status should show blocked")
	}
	if status.BlockedUntil == nil {
		t.Fatal("BlockedUntil should be set")
	}
	expectedUnblock := now.Add(5 * time.Minute)
	if !status.BlockedUntil.Equal(expectedUnblock) {
		t.Errorf("block should expire at %v, got %v", expectedUnblock, *status.BlockedUntil)
	}
}

// TestSecurity_SuccessResetsAfterPartialFailures verifies that a successful
// connection resets the failure counter, preventing false positives for users
// who occasionally mistype their credentials.
func TestSecurity_SuccessResetsAfterPartialFailures(t *testing.T) {
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 100,
		MaxConsecFailures:    5,
		BlockDuration:        5 * time.Minute,
	})

	// Record 4 failures (just under threshold)
	for i := 0; i < 4; i++ {
		rl.RecordFailure("legit-user")
	}

	// Successful connection resets counter
	rl.RecordSuccess("legit-user")

	// Another 4 failures should not trigger block (counter was reset)
	for i := 0; i < 4; i++ {
		rl.RecordFailure("legit-user")
	}

	if err := rl.Allow("legit-user"); err != nil {
		t.Fatalf("should not be blocked — success reset the counter: %v", err)
	}

	status := rl.GetStatus("legit-user")
	if status.Blocked {
		t.Error("should not be blocked after success reset")
	}
}

// TestSecurity_InstanceIsolation verifies that rate limiting is per-instance —
// attacking one instance does not affect access to others.
func TestSecurity_InstanceIsolation(t *testing.T) {
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 2,
		MaxConsecFailures:    2,
		BlockDuration:        5 * time.Minute,
	})

	// Exhaust rate limit and block instance-a
	rl.Allow("instance-a")
	rl.Allow("instance-a")
	rl.RecordFailure("instance-a")
	rl.RecordFailure("instance-a")

	// instance-a should be blocked
	if err := rl.Allow("instance-a"); err == nil {
		t.Error("instance-a should be blocked")
	}

	// instance-b should be completely unaffected
	for i := 0; i < 2; i++ {
		if err := rl.Allow("instance-b"); err != nil {
			t.Fatalf("instance-b attempt %d should be allowed: %v", i+1, err)
		}
	}

	statusB := rl.GetStatus("instance-b")
	if statusB.Blocked {
		t.Error("instance-b should not be blocked by instance-a's failures")
	}
}

// TestSecurity_ConcurrentBruteForce simulates a concurrent brute-force attack
// with multiple goroutines and verifies the rate limiter remains consistent
// under concurrent access.
func TestSecurity_ConcurrentBruteForce(t *testing.T) {
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 10,
		MaxConsecFailures:    5,
		BlockDuration:        5 * time.Minute,
	})

	var wg sync.WaitGroup
	var mu sync.Mutex
	denied := 0

	// 50 concurrent connection attempts (far exceeding the 10/min limit)
	for i := 0; i < 50; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			if err := rl.Allow("concurrent-target"); err != nil {
				mu.Lock()
				denied++
				mu.Unlock()
			}
		}()
	}
	wg.Wait()

	// At most 10 should be allowed, so at least 40 should be denied
	if denied < 40 {
		t.Errorf("expected at least 40 denied attempts, got %d (rate limiter may be leaking under concurrency)", denied)
	}
}

// TestSecurity_BlockDurationExpiry verifies that blocks automatically expire
// after the configured duration, not earlier or later.
func TestSecurity_BlockDurationExpiry(t *testing.T) {
	now := time.Now()
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 100,
		MaxConsecFailures:    2,
		BlockDuration:        5 * time.Minute,
	})
	rl.nowFn = func() time.Time { return now }

	rl.RecordFailure("test-inst")
	rl.RecordFailure("test-inst")

	// Still blocked at 4 minutes 59 seconds
	now = now.Add(4*time.Minute + 59*time.Second)
	if err := rl.Allow("test-inst"); err == nil {
		t.Error("should still be blocked before 5 minute expiry")
	}

	// Unblocked at 5 minutes 1 second
	now = now.Add(2 * time.Second)
	if err := rl.Allow("test-inst"); err != nil {
		t.Fatalf("should be unblocked after 5 minute duration: %v", err)
	}
}

// TestSecurity_RateLimitStatusAccuracy verifies the GetStatus method returns
// accurate information for security monitoring dashboards.
func TestSecurity_RateLimitStatusAccuracy(t *testing.T) {
	now := time.Now()
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 10,
		MaxConsecFailures:    5,
		BlockDuration:        5 * time.Minute,
	})
	rl.nowFn = func() time.Time { return now }

	// Initial status
	status := rl.GetStatus("monitored-inst")
	if status.RecentAttempts != 0 || status.ConsecFailures != 0 || status.Blocked {
		t.Error("initial status should be clean")
	}

	// Record some activity
	rl.Allow("monitored-inst")
	rl.Allow("monitored-inst")
	rl.Allow("monitored-inst")
	rl.RecordFailure("monitored-inst")
	rl.RecordFailure("monitored-inst")

	status = rl.GetStatus("monitored-inst")
	if status.RecentAttempts != 3 {
		t.Errorf("expected 3 recent attempts, got %d", status.RecentAttempts)
	}
	if status.ConsecFailures != 2 {
		t.Errorf("expected 2 consecutive failures, got %d", status.ConsecFailures)
	}
	if status.Blocked {
		t.Error("should not be blocked yet (2 < 5)")
	}
}

// =============================================================================
// Security Testing: IP Restrictions
// =============================================================================

// TestSecurity_IPRestriction_BlocksUnauthorizedIP verifies that connections
// from non-whitelisted IPs are blocked.
func TestSecurity_IPRestriction_BlocksUnauthorizedIP(t *testing.T) {
	err := CheckIPAllowed("10.0.0.5", "192.168.1.0/24, 172.16.0.0/12")
	if err == nil {
		t.Fatal("unauthorized IP 10.0.0.5 should be blocked")
	}
	if !strings.Contains(err.Error(), "not in the allowed list") {
		t.Errorf("error should indicate IP not in allowed list: %v", err)
	}
}

// TestSecurity_IPRestriction_AllowsAuthorizedIP verifies that connections
// from whitelisted IPs are allowed.
func TestSecurity_IPRestriction_AllowsAuthorizedIP(t *testing.T) {
	testCases := []struct {
		sourceIP  string
		allowList string
	}{
		{"192.168.1.100", "192.168.1.0/24"},
		{"172.20.0.5", "172.16.0.0/12"},
		{"10.0.0.1", "10.0.0.1"},
		{"192.168.1.1", "192.168.1.1, 10.0.0.1"},
	}

	for _, tc := range testCases {
		err := CheckIPAllowed(tc.sourceIP, tc.allowList)
		if err != nil {
			t.Errorf("authorized IP %s should be allowed by %q: %v", tc.sourceIP, tc.allowList, err)
		}
	}
}

// TestSecurity_IPRestriction_EmptyAllowList verifies that an empty allow list
// permits all connections (default-allow behavior).
func TestSecurity_IPRestriction_EmptyAllowList(t *testing.T) {
	if err := CheckIPAllowed("1.2.3.4", ""); err != nil {
		t.Fatalf("empty allow list should permit all IPs: %v", err)
	}
}

// TestSecurity_IPRestriction_CIDRBoundary tests CIDR boundary conditions to
// ensure accurate subnet matching.
func TestSecurity_IPRestriction_CIDRBoundary(t *testing.T) {
	// /24 subnet: 192.168.1.0 - 192.168.1.255
	allowList := "192.168.1.0/24"

	// Should be allowed
	allowedIPs := []string{"192.168.1.0", "192.168.1.1", "192.168.1.254", "192.168.1.255"}
	for _, ip := range allowedIPs {
		if err := CheckIPAllowed(ip, allowList); err != nil {
			t.Errorf("IP %s should be within /24 subnet: %v", ip, err)
		}
	}

	// Should be blocked
	blockedIPs := []string{"192.168.0.255", "192.168.2.0", "10.0.0.1"}
	for _, ip := range blockedIPs {
		if err := CheckIPAllowed(ip, allowList); err == nil {
			t.Errorf("IP %s should NOT be within /24 subnet", ip)
		}
	}
}

// TestSecurity_IPRestriction_IPv6Support verifies IPv6 address restriction works.
func TestSecurity_IPRestriction_IPv6Support(t *testing.T) {
	allowList := "::1, fd00::/8"

	// Localhost IPv6 should be allowed
	if err := CheckIPAllowed("::1", allowList); err != nil {
		t.Fatalf("::1 should be allowed: %v", err)
	}

	// fd00:: range should be allowed
	if err := CheckIPAllowed("fd00::1", allowList); err != nil {
		t.Fatalf("fd00::1 should be allowed: %v", err)
	}

	// Public IPv6 should be blocked
	if err := CheckIPAllowed("2001:db8::1", allowList); err == nil {
		t.Error("public IPv6 2001:db8::1 should be blocked")
	}
}

// TestSecurity_IPRestriction_InvalidIPHandling verifies that unparseable IPs
// are rejected, not silently allowed.
func TestSecurity_IPRestriction_InvalidIPHandling(t *testing.T) {
	err := CheckIPAllowed("not-an-ip", "192.168.1.0/24")
	if err == nil {
		t.Fatal("invalid source IP should be rejected, not silently allowed")
	}
	if !strings.Contains(err.Error(), "could not parse") {
		t.Errorf("error should indicate parse failure: %v", err)
	}
}

// TestSecurity_IPRestriction_InvalidCIDRHandling verifies that invalid CIDR
// entries in the allow list produce errors.
func TestSecurity_IPRestriction_InvalidCIDRHandling(t *testing.T) {
	err := CheckIPAllowed("192.168.1.1", "invalid-cidr/xyz")
	if err == nil {
		t.Fatal("invalid CIDR in allow list should produce error")
	}
}

// TestSecurity_IPRestriction_NormalizationConsistency verifies that the
// normalization function produces consistent output for equivalent inputs.
func TestSecurity_IPRestriction_NormalizationConsistency(t *testing.T) {
	// Various representations of the same allow list
	inputs := []string{
		"192.168.1.0/24 , 10.0.0.1",
		"  192.168.1.0/24,10.0.0.1  ",
		"192.168.1.0/24,  10.0.0.1",
	}

	var normalized []string
	for _, input := range inputs {
		n, err := NormalizeAllowList(input)
		if err != nil {
			t.Fatalf("normalize %q: %v", input, err)
		}
		normalized = append(normalized, n)
	}

	// All should produce the same result
	for i := 1; i < len(normalized); i++ {
		if normalized[i] != normalized[0] {
			t.Errorf("normalization inconsistency: %q != %q", normalized[i], normalized[0])
		}
	}
}

// TestSecurity_IPRestriction_MultipleNetworks verifies that multiple
// disjoint networks can be specified.
func TestSecurity_IPRestriction_MultipleNetworks(t *testing.T) {
	allowList := "10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16"

	allowedIPs := []string{
		"10.1.2.3",
		"172.20.0.1",
		"192.168.100.50",
	}
	for _, ip := range allowedIPs {
		if err := CheckIPAllowed(ip, allowList); err != nil {
			t.Errorf("IP %s should be allowed by multi-network list: %v", ip, err)
		}
	}

	blockedIPs := []string{
		"8.8.8.8",
		"1.1.1.1",
		"203.0.113.50",
	}
	for _, ip := range blockedIPs {
		if err := CheckIPAllowed(ip, allowList); err == nil {
			t.Errorf("IP %s should be blocked by multi-network list", ip)
		}
	}
}

// TestSecurity_RateLimiter_SSHManagerIntegration verifies that the SSHManager
// properly enforces rate limiting through its Connect method.
func TestSecurity_RateLimiter_SSHManagerIntegration(t *testing.T) {
	m := NewSSHManager(0)
	defer m.CloseAll()

	// Set very low limit for testing
	m.rateLimiter = NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 2,
		MaxConsecFailures:    2,
		BlockDuration:        5 * time.Minute,
	})

	ctx := t.Context()

	// First 2 attempts are allowed (they fail due to no real SSH server,
	// but the rate limiter allows them through)
	for i := 0; i < 2; i++ {
		_, err := m.Connect(ctx, "pentest-target", "127.0.0.1", 22, "/nonexistent/key")
		// Connection will fail (no SSH server), but it should NOT be a rate limit error
		if err != nil && strings.Contains(err.Error(), "rate limit exceeded") {
			t.Fatalf("attempt %d should not be rate limited", i+1)
		}
	}

	// 3rd attempt should be rate limited
	_, err := m.Connect(ctx, "pentest-target", "127.0.0.1", 22, "/nonexistent/key")
	if err == nil {
		t.Fatal("expected error from rate limited connection")
	}
	if !strings.Contains(err.Error(), "rate limit exceeded") {
		t.Errorf("expected rate limit error, got: %v", err)
	}
}

// TestSecurity_RateLimiter_EventEmission verifies that rate limit violations
// emit events for security monitoring.
func TestSecurity_RateLimiter_EventEmission(t *testing.T) {
	m := NewSSHManager(0)
	defer m.CloseAll()

	// Configure to block immediately after 1 failure
	m.rateLimiter = NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 100,
		MaxConsecFailures:    1,
		BlockDuration:        5 * time.Minute,
	})

	// Trigger block
	m.rateLimiter.RecordFailure("event-test")

	// Attempt connection (should be blocked and emit event)
	ctx := t.Context()
	m.Connect(ctx, "event-test", "127.0.0.1", 22, "/nonexistent/key")

	// Verify rate_limited event was emitted
	events := m.GetEvents("event-test")
	found := false
	for _, e := range events {
		if e.Type == EventRateLimited {
			found = true
			break
		}
	}
	if !found {
		t.Error("rate limit violation should emit EventRateLimited for security monitoring")
	}
}

// TestSecurity_SlidingWindowAccuracy verifies the sliding window rate limiter
// correctly ages out old attempts and allows new ones.
func TestSecurity_SlidingWindowAccuracy(t *testing.T) {
	now := time.Now()
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 5,
		MaxConsecFailures:    100,
		BlockDuration:        1 * time.Minute,
	})
	rl.nowFn = func() time.Time { return now }

	// Fill up the window at different times
	for i := 0; i < 5; i++ {
		now = now.Add(10 * time.Second) // 10s, 20s, 30s, 40s, 50s
		rl.Allow("sliding-test")
	}

	// Should be blocked at 50s
	now = now.Add(1 * time.Second) // 51s
	if err := rl.Allow("sliding-test"); err == nil {
		t.Fatal("should be rate limited with 5 attempts in window")
	}

	// At 71s, the first attempt (at 10s) ages out
	now = now.Add(20 * time.Second) // 71s
	if err := rl.Allow("sliding-test"); err != nil {
		t.Fatalf("first attempt should have aged out: %v", err)
	}
}

// TestSecurity_ManyInstances verifies that the rate limiter handles a large
// number of distinct instances without issues.
func TestSecurity_ManyInstances(t *testing.T) {
	rl := NewRateLimiter(RateLimitConfig{
		MaxAttemptsPerMinute: 5,
		MaxConsecFailures:    3,
		BlockDuration:        1 * time.Minute,
	})

	// Register 1000 distinct instances
	for i := 0; i < 1000; i++ {
		name := fmt.Sprintf("inst-%d", i)
		if err := rl.Allow(name); err != nil {
			t.Fatalf("instance %s should be allowed: %v", name, err)
		}
	}

	// Each should have independent state
	status0 := rl.GetStatus("inst-0")
	if status0.RecentAttempts != 1 {
		t.Errorf("inst-0 should have 1 attempt, got %d", status0.RecentAttempts)
	}
}
