package sshaudit

import (
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/gluk-w/claworc/control-plane/internal/database"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

func setupSecurityTestDB(t *testing.T) *gorm.DB {
	t.Helper()
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Silent),
	})
	if err != nil {
		t.Fatalf("open test DB: %v", err)
	}
	if err := db.AutoMigrate(&database.SSHAuditLog{}); err != nil {
		t.Fatalf("auto-migrate: %v", err)
	}
	return db
}

// =============================================================================
// Security Testing: Audit Log Completeness
// =============================================================================

// TestSecurity_AllEventTypesLogged verifies that all defined SSH event types
// can be logged and queried correctly.
func TestSecurity_AllEventTypesLogged(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)

	allEvents := []string{
		EventConnectionEstablished,
		EventConnectionTerminated,
		EventCommandExecution,
		EventFileOperation,
		EventTerminalSessionStart,
		EventTerminalSessionEnd,
		EventKeyRotation,
		EventConnectionFailed,
		EventFingerprintMismatch,
		EventIPRestricted,
	}

	for _, et := range allEvents {
		err := a.Log(AuditEntry{
			InstanceID:   1,
			InstanceName: "bot-test",
			EventType:    et,
			Username:     "admin",
			SourceIP:     "10.0.0.1",
			Details:      "security test: " + et,
		})
		if err != nil {
			t.Fatalf("failed to log event type %q: %v", et, err)
		}
	}

	// Verify all events are queryable
	for _, et := range allEvents {
		result, err := a.Query(QueryOptions{EventType: et})
		if err != nil {
			t.Fatalf("failed to query event type %q: %v", et, err)
		}
		if result.Total != 1 {
			t.Errorf("expected 1 entry for event type %q, got %d", et, result.Total)
		}
	}

	// Verify total count
	result, err := a.Query(QueryOptions{})
	if err != nil {
		t.Fatalf("total query failed: %v", err)
	}
	if result.Total != int64(len(allEvents)) {
		t.Errorf("expected %d total events, got %d", len(allEvents), result.Total)
	}
}

// TestSecurity_AuditLogFieldsCapture verifies that all audit log fields
// (user, source IP, instance, timestamp, details) are correctly captured.
func TestSecurity_AuditLogFieldsCapture(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)

	err := a.Log(AuditEntry{
		InstanceID:   42,
		InstanceName: "bot-production",
		EventType:    EventConnectionEstablished,
		Username:     "security-admin",
		SourceIP:     "203.0.113.50",
		Details:      "SSH tunnel established to VNC",
		DurationMs:   12345,
	})
	if err != nil {
		t.Fatalf("log failed: %v", err)
	}

	var record database.SSHAuditLog
	db.First(&record)

	if record.InstanceID != 42 {
		t.Errorf("InstanceID: expected 42, got %d", record.InstanceID)
	}
	if record.InstanceName != "bot-production" {
		t.Errorf("InstanceName: expected 'bot-production', got %q", record.InstanceName)
	}
	if record.EventType != EventConnectionEstablished {
		t.Errorf("EventType: expected %q, got %q", EventConnectionEstablished, record.EventType)
	}
	if record.Username != "security-admin" {
		t.Errorf("Username: expected 'security-admin', got %q", record.Username)
	}
	if record.SourceIP != "203.0.113.50" {
		t.Errorf("SourceIP: expected '203.0.113.50', got %q", record.SourceIP)
	}
	if record.Details != "SSH tunnel established to VNC" {
		t.Errorf("Details: expected 'SSH tunnel established to VNC', got %q", record.Details)
	}
	if record.Duration != 12345 {
		t.Errorf("Duration: expected 12345, got %d", record.Duration)
	}
	if record.CreatedAt.IsZero() {
		t.Error("CreatedAt should be auto-set, got zero value")
	}
}

// TestSecurity_SecurityEventTypes verifies that all security-specific event
// types (fingerprint mismatch, IP restricted) include the expected details.
func TestSecurity_SecurityEventTypes(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)
	SetGlobalForTest(a)
	t.Cleanup(func() { ResetGlobalForTest() })

	// Log fingerprint mismatch
	LogFingerprintMismatch(1, "bot-compromised", "admin",
		"expected SHA256:abc123, got SHA256:xyz789")

	// Log IP restriction
	LogIPRestricted(2, "bot-restricted", "attacker", "10.0.0.99",
		"IP not in allowed list")

	// Verify fingerprint mismatch was logged
	result, err := a.Query(QueryOptions{EventType: EventFingerprintMismatch})
	if err != nil {
		t.Fatalf("query fingerprint mismatch: %v", err)
	}
	if result.Total != 1 {
		t.Fatalf("expected 1 fingerprint mismatch event, got %d", result.Total)
	}
	entry := result.Entries[0]
	if !strings.Contains(entry.Details, "SHA256:abc123") {
		t.Errorf("fingerprint mismatch details should contain expected fingerprint: %q", entry.Details)
	}
	if !strings.Contains(entry.Details, "SHA256:xyz789") {
		t.Errorf("fingerprint mismatch details should contain actual fingerprint: %q", entry.Details)
	}

	// Verify IP restriction was logged
	result2, err := a.Query(QueryOptions{EventType: EventIPRestricted})
	if err != nil {
		t.Fatalf("query IP restricted: %v", err)
	}
	if result2.Total != 1 {
		t.Fatalf("expected 1 IP restricted event, got %d", result2.Total)
	}
	entry2 := result2.Entries[0]
	if entry2.SourceIP != "10.0.0.99" {
		t.Errorf("IP restricted event should capture source IP: %q", entry2.SourceIP)
	}
}

// =============================================================================
// Security Testing: Log Retention Policy
// =============================================================================

// TestSecurity_RetentionPolicyEnforced verifies that old audit logs are purged
// according to the retention policy, preventing unbounded log growth.
func TestSecurity_RetentionPolicyEnforced(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 30) // 30-day retention

	now := time.Now()
	a.SetNowFunc(func() time.Time { return now })

	// Create logs at various ages
	ages := []int{5, 15, 25, 31, 45, 60, 90}
	for _, days := range ages {
		db.Create(&database.SSHAuditLog{
			InstanceID:   1,
			InstanceName: "bot-retention",
			EventType:    EventConnectionEstablished,
			Username:     "admin",
			CreatedAt:    now.AddDate(0, 0, -days),
		})
	}

	// Purge with default retention (30 days)
	deleted, err := a.PurgeOlderThan(0)
	if err != nil {
		t.Fatalf("purge failed: %v", err)
	}

	// Entries older than 30 days: 31, 45, 60, 90 = 4 entries
	if deleted != 4 {
		t.Errorf("expected 4 entries purged (31, 45, 60, 90 days old), got %d", deleted)
	}

	// Remaining entries: 5, 15, 25 days old
	var count int64
	db.Model(&database.SSHAuditLog{}).Count(&count)
	if count != 3 {
		t.Errorf("expected 3 remaining entries, got %d", count)
	}
}

// TestSecurity_RetentionPreservesRecentLogs verifies that the purge does not
// accidentally delete recent logs.
func TestSecurity_RetentionPreservesRecentLogs(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)

	now := time.Now()
	a.SetNowFunc(func() time.Time { return now })

	// Create 20 recent logs (within retention period)
	for i := 0; i < 20; i++ {
		db.Create(&database.SSHAuditLog{
			InstanceID:   1,
			InstanceName: "bot-recent",
			EventType:    EventConnectionEstablished,
			Username:     "admin",
			CreatedAt:    now.AddDate(0, 0, -i),
		})
	}

	deleted, err := a.PurgeOlderThan(90)
	if err != nil {
		t.Fatalf("purge failed: %v", err)
	}
	if deleted != 0 {
		t.Errorf("no recent logs should be purged, but %d were deleted", deleted)
	}

	var count int64
	db.Model(&database.SSHAuditLog{}).Count(&count)
	if count != 20 {
		t.Errorf("all 20 recent logs should remain, got %d", count)
	}
}

// TestSecurity_RetentionCustomDays verifies that custom retention periods are
// respected during purge.
func TestSecurity_RetentionCustomDays(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)

	now := time.Now()
	a.SetNowFunc(func() time.Time { return now })

	// Create logs at 5, 10, 15, 20 days old
	for _, days := range []int{5, 10, 15, 20} {
		db.Create(&database.SSHAuditLog{
			InstanceID:   1,
			InstanceName: "bot-custom",
			EventType:    EventConnectionEstablished,
			Username:     "admin",
			CreatedAt:    now.AddDate(0, 0, -days),
		})
	}

	// Purge with custom 12-day retention
	deleted, err := a.PurgeOlderThan(12)
	if err != nil {
		t.Fatalf("purge failed: %v", err)
	}

	// Entries older than 12 days: 15, 20 = 2 entries
	if deleted != 2 {
		t.Errorf("expected 2 entries purged, got %d", deleted)
	}
}

// =============================================================================
// Security Testing: Audit Log Query Filtering
// =============================================================================

// TestSecurity_QueryByMultipleFilters verifies that compound audit log queries
// correctly narrow results using multiple criteria simultaneously.
func TestSecurity_QueryByMultipleFilters(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)

	// Create diverse audit entries
	entries := []AuditEntry{
		{InstanceID: 1, InstanceName: "bot-a", EventType: EventFileOperation, Username: "admin", SourceIP: "10.0.0.1"},
		{InstanceID: 1, InstanceName: "bot-a", EventType: EventFileOperation, Username: "viewer", SourceIP: "10.0.0.2"},
		{InstanceID: 2, InstanceName: "bot-b", EventType: EventFileOperation, Username: "admin", SourceIP: "10.0.0.1"},
		{InstanceID: 1, InstanceName: "bot-a", EventType: EventConnectionEstablished, Username: "admin", SourceIP: "10.0.0.1"},
		{InstanceID: 1, InstanceName: "bot-a", EventType: EventFingerprintMismatch, Username: "admin", SourceIP: "10.0.0.1"},
	}
	for _, e := range entries {
		if err := a.Log(e); err != nil {
			t.Fatalf("log failed: %v", err)
		}
	}

	// Query: instance 1, file operations, by admin
	result, err := a.Query(QueryOptions{
		InstanceID: 1,
		EventType:  EventFileOperation,
		Username:   "admin",
	})
	if err != nil {
		t.Fatalf("query failed: %v", err)
	}
	if result.Total != 1 {
		t.Errorf("expected 1 entry matching all filters, got %d", result.Total)
	}
}

// TestSecurity_AuditLogForensicQuery simulates a forensic investigation query:
// find all security events for a specific instance within a time window.
func TestSecurity_AuditLogForensicQuery(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)

	now := time.Now()
	incidentTime := now.Add(-2 * time.Hour)

	// Create timeline of events
	db.Create(&database.SSHAuditLog{InstanceID: 1, InstanceName: "bot-compromised", EventType: EventConnectionEstablished, Username: "normal", CreatedAt: now.Add(-24 * time.Hour)})
	db.Create(&database.SSHAuditLog{InstanceID: 1, InstanceName: "bot-compromised", EventType: EventFingerprintMismatch, Username: "attacker", CreatedAt: incidentTime})
	db.Create(&database.SSHAuditLog{InstanceID: 1, InstanceName: "bot-compromised", EventType: EventConnectionEstablished, Username: "attacker", CreatedAt: incidentTime.Add(1 * time.Minute)})
	db.Create(&database.SSHAuditLog{InstanceID: 1, InstanceName: "bot-compromised", EventType: EventFileOperation, Username: "attacker", Details: "read: /etc/shadow", CreatedAt: incidentTime.Add(5 * time.Minute)})
	db.Create(&database.SSHAuditLog{InstanceID: 1, InstanceName: "bot-compromised", EventType: EventConnectionTerminated, Username: "attacker", CreatedAt: incidentTime.Add(10 * time.Minute)})
	db.Create(&database.SSHAuditLog{InstanceID: 2, InstanceName: "bot-clean", EventType: EventConnectionEstablished, Username: "admin", CreatedAt: incidentTime})

	// Forensic query: all events for bot-compromised in the last 3 hours
	since := now.Add(-3 * time.Hour)
	result, err := a.Query(QueryOptions{
		InstanceName: "bot-compromised",
		Since:        &since,
	})
	if err != nil {
		t.Fatalf("forensic query failed: %v", err)
	}

	// Should find 4 events (fingerprint mismatch, connection, file op, disconnect)
	if result.Total != 4 {
		t.Errorf("expected 4 incident events, got %d", result.Total)
	}

	// Events should be in reverse chronological order
	if len(result.Entries) > 0 && result.Entries[0].EventType != EventConnectionTerminated {
		t.Errorf("most recent event should be connection terminated, got %q", result.Entries[0].EventType)
	}
}

// TestSecurity_EventTypeUniqueness verifies that all event type constants are
// unique and non-empty (prevents accidental event type collisions).
func TestSecurity_EventTypeUniqueness(t *testing.T) {
	allEvents := []string{
		EventConnectionEstablished,
		EventConnectionTerminated,
		EventCommandExecution,
		EventFileOperation,
		EventTerminalSessionStart,
		EventTerminalSessionEnd,
		EventKeyRotation,
		EventConnectionFailed,
		EventFingerprintMismatch,
		EventIPRestricted,
	}

	seen := make(map[string]bool)
	for _, et := range allEvents {
		if et == "" {
			t.Error("event type constant should not be empty")
			continue
		}
		if seen[et] {
			t.Errorf("duplicate event type constant: %q", et)
		}
		seen[et] = true
	}

	if len(seen) != len(allEvents) {
		t.Errorf("expected %d unique event types, got %d", len(allEvents), len(seen))
	}
}

// =============================================================================
// Security Testing: Helper Functions
// =============================================================================

// TestSecurity_HelpersSafeWithNilAuditor verifies that all helper functions
// gracefully handle a nil global auditor (no panics, no crashes).
func TestSecurity_HelpersSafeWithNilAuditor(t *testing.T) {
	ResetGlobalForTest()
	t.Cleanup(func() { ResetGlobalForTest() })

	// None of these should panic
	LogConnection(1, "bot-test", "admin", "10.0.0.1")
	LogDisconnection(1, "bot-test", "admin", "reason", 1000)
	LogConnectionFailed(1, "bot-test", "admin", "error")
	LogCommand(1, "bot-test", "admin", "ls", "ok")
	LogFileOperation(1, "bot-test", "admin", "read", "/tmp/file")
	LogTerminalSessionStart(1, "bot-test", "admin", "sess-1", "10.0.0.1")
	LogTerminalSessionEnd(1, "bot-test", "admin", "sess-1", 5000)
	LogFingerprintMismatch(1, "bot-test", "admin", "mismatch details")
	LogIPRestricted(1, "bot-test", "admin", "10.0.0.99", "blocked")
	LogKeyRotation(1, "bot-test", "admin", "SHA256:test")
}

// TestSecurity_KeyRotationAuditTrail verifies that key rotation events create
// a proper audit trail with fingerprint information.
func TestSecurity_KeyRotationAuditTrail(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)
	SetGlobalForTest(a)
	t.Cleanup(func() { ResetGlobalForTest() })

	LogKeyRotation(1, "bot-prod", "admin", "SHA256:newkey123")

	result, err := a.Query(QueryOptions{EventType: EventKeyRotation})
	if err != nil {
		t.Fatalf("query failed: %v", err)
	}
	if result.Total != 1 {
		t.Fatalf("expected 1 key rotation event, got %d", result.Total)
	}

	entry := result.Entries[0]
	if !strings.Contains(entry.Details, "SHA256:newkey123") {
		t.Errorf("key rotation event should contain new fingerprint in details: %q", entry.Details)
	}
	if entry.Username != "admin" {
		t.Errorf("key rotation should record the user who performed it: %q", entry.Username)
	}
}

// TestSecurity_AuditLogMaxLimit verifies that the query API enforces a
// maximum result limit to prevent excessive data retrieval.
func TestSecurity_AuditLogMaxLimit(t *testing.T) {
	db := setupSecurityTestDB(t)
	a := NewAuditor(db, 90)

	// Request an excessively large limit
	result, err := a.Query(QueryOptions{Limit: 999999})
	if err != nil {
		t.Fatalf("query failed: %v", err)
	}
	if result.Limit > 1000 {
		t.Errorf("query limit should be capped at 1000, got %d", result.Limit)
	}
}

// TestSecurity_SourceIPExtraction tests that the ExtractSourceIP function
// correctly extracts client IPs from various HTTP header configurations,
// respecting priority order: X-Forwarded-For > X-Real-IP > RemoteAddr.
func TestSecurity_SourceIPExtraction(t *testing.T) {
	tests := []struct {
		name     string
		xff      string
		xri      string
		remote   string
		expected string
	}{
		{
			name:     "XFF takes priority",
			xff:      "203.0.113.50, 70.41.3.18",
			xri:      "198.51.100.10",
			remote:   "192.0.2.1:12345",
			expected: "203.0.113.50",
		},
		{
			name:     "XRI used when no XFF",
			xri:      "198.51.100.10",
			remote:   "192.0.2.1:12345",
			expected: "198.51.100.10",
		},
		{
			name:     "RemoteAddr fallback",
			remote:   "192.0.2.1:12345",
			expected: "192.0.2.1",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := httptest.NewRequest("GET", "/", nil)
			if tt.xff != "" {
				r.Header.Set("X-Forwarded-For", tt.xff)
			}
			if tt.xri != "" {
				r.Header.Set("X-Real-Ip", tt.xri)
			}
			if tt.remote != "" {
				r.RemoteAddr = tt.remote
			}
			ip := ExtractSourceIP(r)
			if ip != tt.expected {
				t.Errorf("expected %q, got %q", tt.expected, ip)
			}
		})
	}
}
